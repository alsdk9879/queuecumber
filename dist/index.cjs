"use strict";class r{version="1.0.12";items=[];breakWhenError=!1;batchSize=1;onProgress;completed=[];runningBatches=[];runningSlots=[];get batchToProcess(){return Math.ceil(this.items.length/this.batchSize)}get batchProcessFinished(){let e=Object.keys(this.completed).length===this.runningBatches.length;if(e){const s=this.completed;this.completed=[],this.runningBatches=[],this.runningSlots=[],this.onProgress&&this.onProgress({batchToProcess:this.batchToProcess,itemsToProcess:this.items.length,completed:s})}return e}constructor(t){if(this.breakWhenError=!!t?.breakWhenError,this.batchSize=t?.batchSize??1,typeof this.batchSize!="number"||this.batchSize<1)throw new Error("batchSize must be at least 1");if(t?.onProgress)if(typeof t.onProgress=="function")this.onProgress=t.onProgress;else throw new Error("onProgress must be a function")}add(t){const e=Array.isArray(t)?t:[t];for(const s of e){if(typeof s!="function")throw new Error("Each job must be a function that returns a Promise");this.items.push(s)}this.processNext()}terminate(){this.items=[]}processNext(){if(this.items.length===0)return;const t=this.batchSize-this.runningBatches.length;if(!(t<=0)){this.runningBatches.push(...this.items.splice(0,t));for(let e=0;e<this.runningBatches.length;e++)this.runningSlots?.[e]||(this.runningSlots[e]=!0,this.runningBatches[e]().then(s=>this.completed[e]?s:(this.completed[e]=s,this.batchProcessFinished?this.processNext():s)).catch(s=>{if(this.breakWhenError)throw s;return this.completed[e]=s,this.batchProcessFinished?this.processNext():s}))}}}module.exports=r;
//# sourceMappingURL=index.cjs.map
